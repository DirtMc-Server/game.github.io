<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Space Master â€” Difficulty & Golden Rocks</title>
<style>
:root{
  --bg1:#020417; --bg2:#000006;
  --neon:#00f0ff; --accent:#8b5cff; --glass: rgba(255,255,255,0.04);
}
*{box-sizing:border-box;font-family:Inter, "Segoe UI", Tahoma, Arial; color:#eafcff}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));-webkit-user-select:none;user-select:none}
canvas{display:block;position:fixed; inset:0; z-index:0;}
/* UI */
#topBar{position:fixed;left:12px;right:12px;top:10px;display:flex;justify-content:space-between;align-items:center;z-index:70;pointer-events:none}
.title{font-weight:800;font-size:18px;pointer-events:auto}
.topBtns{pointer-events:auto;display:flex;gap:8px}
.btn{padding:8px 12px;border-radius:10px;border:none;cursor:pointer;background:linear-gradient(90deg,var(--neon),var(--accent));color:#021;font-weight:800;box-shadow:0 8px 22px rgba(0,0,0,0.6)}
#bottomHUD{position:fixed;left:12px;right:12px;bottom:12px;z-index:70;display:flex;justify-content:space-between;gap:12px;padding:12px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.22));backdrop-filter: blur(6px);border:1px solid rgba(0,255,255,0.04);pointer-events:auto}
.hudItem{display:flex;flex-direction:column;gap:4px}
.hudLabel{font-size:12px;color:rgba(200,240,255,0.8)}
.hudValue{font-weight:800;font-size:18px;color:var(--neon)}
/* joystick */
#joystick{position:fixed;left:50%;transform:translateX(-50%);bottom:120px;width:150px;height:150px;border-radius:50%;background:rgba(255,255,255,0.03);display:none;z-index:80;border:1px solid rgba(255,255,255,0.04);pointer-events:auto;touch-action:none;}
#stick{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:64px;height:64px;border-radius:50%;background:linear-gradient(180deg,#cfd,#909);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
/* settings modal */
#settingsModal{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;z-index:120;align-items:center;justify-content:center}
.settingsCard{width:360px;background:linear-gradient(180deg, rgba(10,14,22,0.96), rgba(4,6,10,0.98));border-radius:12px;padding:14px;border:1px solid rgba(0,255,255,0.04)}
.row{display:flex;align-items:center;justify-content:space-between;margin:10px 0}
.select, input[type="range"]{width:100%}
.small{font-size:13px;color:rgba(200,240,255,0.7)}
.tooltip{position:fixed;z-index:9999;padding:8px 10px;background:rgba(2,6,20,0.9);border-radius:8px;border:1px solid rgba(0,255,255,0.06);display:none;pointer-events:none}
</style>
</head>
<body>

<canvas id="bg"></canvas>
<canvas id="game"></canvas>

<div id="topBar">
  <div class="title">ğŸš€ Space Master â€” Updated</div>
  <div class="topBtns">
    <button id="openTree" class="btn">ğŸŒ³ Ø´Ø¬Ø±Ø© Ø§Ù„ØªØ·ÙˆÙŠØ±</button>
    <button id="openSettings" class="btn">âš™ï¸ Settings</button>
    <button id="resetBtn" class="btn" title="Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­ÙØ¸">Ø¥Ø¹Ø§Ø¯Ø©</button>
  </div>
</div>

<div id="bottomHUD">
  <div class="hudItem"><div class="hudLabel">â¤ Ø§Ù„ØµØ­Ø©</div><div class="hudValue" id="hpVal">20</div></div>
  <div class="hudItem"><div class="hudLabel">ğŸ’° Ø§Ù„ÙÙ„ÙˆØ³</div><div class="hudValue" id="moneyVal">0</div></div>
  <div class="hudItem"><div class="hudLabel">â­ Ø§Ù„Ù†Ù‚Ø§Ø·</div><div class="hudValue" id="scoreVal">0</div></div>
  <div class="hudItem"><div class="hudLabel">âš”ï¸ Ø¶Ø±Ø±</div><div class="hudValue" id="dmgVal">3</div></div>
</div>

<div id="joystick"><div id="stick"></div></div>

<!-- settings modal -->
<div id="settingsModal">
  <div class="settingsCard">
    <div style="font-weight:800;font-size:16px">Settings</div>
    <div class="small" style="margin-top:6px">Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø§Ù„Ø¢Ù†: PC â€” ØºÙŠØ±Ù‡ Ù…Ù† Ù‡Ù†Ø§</div>

    <div class="row">
      <div>ÙˆØ¶Ø¹ Ø§Ù„ØªØ­ÙƒÙ…</div>
      <select id="controlSelect" class="select">
        <option value="pc">PC â€” Ù…Ø§ÙˆØ³ (Ø§ÙØªØ±Ø§Ø¶ÙŠ)</option>
        <option value="mobile">Mobile â€” Ø¬ÙˆØ§Ù„ (Ù„Ù…Ø³ / Ø¬ÙˆØ³ØªÙŠÙƒ)</option>
      </select>
    </div>

    <div class="row">
      <div>Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª</div>
      <input id="volRange" type="range" min="0" max="1" step="0.01" value="0.6">
    </div>

    <div class="row">
      <div>ØªØ´ØºÙŠÙ„ Ù…Ø¤Ø«Ø±Ø§Øª ØµÙˆØªÙŠØ©</div>
      <input id="fxToggle" type="checkbox" checked>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="saveSettings" class="btn">Ø­ÙØ¸</button>
      <button id="closeSettings" class="btn" style="background:linear-gradient(90deg,#fff,#b6f7ff)">Ø¥ØºÙ„Ø§Ù‚</button>
    </div>
  </div>
</div>

<div id="upgradeOverlay" style="display:none;z-index:110;position:fixed;inset:0;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.9));align-items:center;justify-content:center">
  <div style="width:92%;max-width:1200px;height:86%;background:linear-gradient(180deg, rgba(8,12,20,0.9), rgba(2,4,8,0.98));border-radius:12px;padding:12px;display:flex;gap:12px;box-shadow:0 30px 80px rgba(0,0,0,0.6);border:1px solid rgba(0,255,255,0.04)">
    <div style="width:320px;display:flex;flex-direction:column;gap:12px">
      <div style="font-weight:800">Ø´Ø¬Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª</div>
      <div style="font-size:13px;color:rgba(200,240,255,0.7)">Ø§Ø´ØªØ±Ù Ù„ÙØªØ­ ÙØ±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯Ø© â€” Ø§Ø³Ø­Ø¨ Ø§Ù„Ø´Ø¬Ø±Ø© Ù„ØªØ­Ø±ÙŠÙƒÙ‡Ø§</div>
      <div style="display:flex;gap:8px;margin-top:auto">
        <button id="closeTreeBtn" class="btn">Ø±Ø¬ÙˆØ¹</button>
        <button id="resetTree" class="btn" style="background:linear-gradient(90deg,#ff9,#f98)">Ø§Ø¹Ø§Ø¯Ø© Ø§Ù„Ø´Ø¬Ø±Ø©</button>
      </div>
    </div>

    <div style="flex:1;position:relative;border-radius:8px;background:radial-gradient(ellipse at 30% 10%, rgba(0,255,220,0.02), transparent 6%), radial-gradient(ellipse at 80% 90%, rgba(139,92,255,0.012), transparent 6%)">
      <div id="treeArea" style="position:absolute;left:0;top:0;width:2200px;height:1600px;cursor:grab"></div>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
/* --------------------------- canvases --------------------------- */
const bg = document.getElementById('bg'), game = document.getElementById('game');
const ctxBG = bg.getContext('2d'), ctx = game.getContext('2d');
function resize(){ bg.width = game.width = innerWidth; bg.height = game.height = innerHeight; }
addEventListener('resize', resize); resize();

/* --------------------------- audio (fx manager) --------------------------- */
const AudioCtx = window.AudioContext ? new AudioContext() : null;
let masterGain = null;
if(AudioCtx){ masterGain = AudioCtx.createGain(); masterGain.gain.value = 0.6; masterGain.connect(AudioCtx.destination); }
function setVolume(v){ if(masterGain) masterGain.gain.value = v; }

/* a single playFX implementation used across script */
function playFX(name){
  if(!AudioCtx) return;
  // check settings
  if(!state.settings || state.settings.fx === false) return;
  const now = AudioCtx.currentTime;
  if(name === 'fire'){
    const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain();
    o.type = 'sawtooth'; o.frequency.value = 800 + Math.random()*120; g.gain.value = 0.03;
    o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 0.055);
  } else if(name === 'hit'){
    const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain();
    o.type='triangle'; o.frequency.value = 340 + Math.random()*80; g.gain.value = 0.04; o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 0.07);
  } else if(name === 'destroy'){
    for(let i=0;i<3;i++){ const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type='sine'; o.frequency.value = 220 + i*60; g.gain.value = 0.02; o.connect(g); g.connect(masterGain); o.start(now + i*0.01); o.stop(now + 0.12 + i*0.02); }
  } else if(name === 'upgrade'){
    const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type='triangle'; o.frequency.value = 1200; g.gain.value = 0.03; o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 0.12);
  } else if(name === 'spawn'){
    const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type='sine'; o.frequency.value = 300; g.gain.value = 0.01; o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 0.06);
  } else if(name === 'death'){
    const o = AudioCtx.createOscillator(); const g = AudioCtx.createGain(); o.type='sawtooth'; o.frequency.value = 120; g.gain.value = 0.06; o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 0.28);
  }
}

/* --------------------------- persistent state --------------------------- */
const SAVE = 'space_master_settings_v2';
let state = { money:0, score:0, upgrades:{}, settings:{ mode:'pc', volume:0.6, fx:true } };
try{ const s = localStorage.getItem(SAVE); if(s) state = JSON.parse(s); }catch(e){}
setVolume(state.settings.volume || 0.6);

/* --------------------------- core objects & defaults --------------------------- */
let mode = state.settings.mode || 'pc'; // default PC
const joystick = document.getElementById('joystick'), stick = document.getElementById('stick');
if(mode === 'mobile') joystick.style.display = 'block'; else joystick.style.display = 'none';

const player = { x: innerWidth/2, y: innerHeight/2, r:20, health:20, maxHealth:20, damage:3, fireRate:1800, missiles:1, missileSpeed:6, speed:3, shield:0, regen:0 };

let rocks = [], missiles = [], particles = [];

/* ----- DIFFICULTY + SURVIVAL TRACKING ----- */
let startSurvival = performance.now(); // time since last death/spawn reset
let difficultyTimer = performance.now();
let difficultyLevel = 0;
let goldenChance = 0.01; // base chance for golden rock spawn (1%)
const DIFF_INCREASE_INTERVAL = 20000; // every 20s increase difficulty
const MAX_GOLDEN_CHANCE = 0.18; // max 18%

/* ----- spawn config ----- */
const spawnConfig = {
  baseSpawnInterval: 1200,
  spawnInterval: 1200,
  minSpawnInterval: 350,
  baseRockSpeed: 0.45, // lowered base speed a bit (we slowed rocks)
};

/* spawn rock with random velocity; can be golden */
function spawnRock(edge){
  const isGolden = Math.random() < goldenChance;
  const r = Math.random()*38 + 12;
  let x,y;
  const side = edge ?? Math.floor(Math.random()*4);
  if(side===0){ x = -r-10; y = Math.random()*innerHeight; }
  else if(side===1){ x = innerWidth + r+10; y = Math.random()*innerHeight; }
  else if(side===2){ x = Math.random()*innerWidth; y = -r-10; }
  else { x = Math.random()*innerWidth; y = innerHeight + r + 10; }
  // random direction velocity
  const angle = Math.random() * Math.PI * 2;
  const speed = spawnConfig.baseRockSpeed + Math.random()*0.6; // base + small random
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;
  const baseHP = Math.ceil(r/3)*6;
  const baseValue = Math.ceil(r/3)*6;
  if(isGolden){
    rocks.push({ x, y, r: r*1.05, hp: Math.ceil(baseHP*1.9), vx, vy, baseSpeed: speed, value: Math.ceil(baseValue*3), golden:true });
  } else {
    rocks.push({ x, y, r, hp: baseHP, vx, vy, baseSpeed: speed, value: baseValue, golden:false });
  }
  playFX('spawn');
}

/* spawn initial */
for(let i=0;i<8;i++) spawnRock();

/* --------------------------- upgrades (same defs) --------------------------- */
const UP = {
  damage: {name:'Ø¬Ø°Ø±: Ø¶Ø±Ø±', desc:'ÙŠØ²ÙŠØ¯ Ø¶Ø±Ø± Ø§Ù„ØµÙˆØ§Ø±ÙŠØ®', cost:60, max:6, deps:[], apply:lvl=> player.damage = 3 + lvl*2},
  fireRate: {name:'Ø¬Ø°Ø±: Ø³Ø±Ø¹Ø© Ø§Ø·Ù„Ø§Ù‚', desc:'ÙŠÙ‚Ù„Ù„ Ø²Ù…Ù† Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚', cost:80, max:6, deps:['damage'], apply:lvl=> player.fireRate = Math.max(250, 1800 - lvl*220)},
  missiles: {name:'Ø¬Ø°Ø±: ØµÙˆØ§Ø±ÙŠØ®', desc:'Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„ØµÙˆØ§Ø±ÙŠØ®', cost:90, max:5, deps:['damage'], apply:lvl=> player.missiles = 1 + lvl},
  missileSpeed: {name:'Ø³Ø±Ø¹Ø© Ø§Ù„ØµÙˆØ§Ø±ÙŠØ®', desc:'ØªØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„ØµÙˆØ§Ø±ÙŠØ®', cost:80, max:5, deps:['missiles'], apply:lvl=> player.missileSpeed = 6 + lvl*2},
  explosion: {name:'Ø§Ù†ÙØ¬Ø§Ø±', desc:'ØµÙˆØ§Ø±ÙŠØ® ØªØ³Ø¨Ø¨ Ø§Ù†ÙØ¬Ø§Ø± ØµØºÙŠØ±', cost:140, max:3, deps:['missileSpeed'], apply:lvl=> player.explosion = lvl},
  money: {name:'Ø°Ù‡Ø¨', desc:'Ø²ÙŠØ§Ø¯Ø© Ù…ÙƒØ§ÙØ¢Øª Ø§Ù„ØªØ¯Ù…ÙŠØ±', cost:120, max:5, deps:['missiles'], apply:lvl=> player.moneyMul = 1 + lvl*0.18},
  hpMax: {name:'Ù‚Ù„Ø¨ Ø§Ù‚ÙˆÙ‰', desc:'Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„ØµØ­Ø©', cost:120, max:5, deps:['fireRate'], apply:lvl=> { player.maxHealth = 20 + lvl*6; if(player.health>player.maxHealth) player.health = player.maxHealth } },
  regen: {name:'ØªØ¬Ø¯Ø¯', desc:'Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ØµØ­Ø© Ø¨Ù…Ø±ÙˆØ± Ø§Ù„ÙˆÙ‚Øª', cost:160, max:3, deps:['hpMax'], apply:lvl=> player.regen = lvl},
  rockDensity: {name:'Ø²Ø®Ù… Ø§Ù„ØµØ®ÙˆØ±', desc:'ÙŠØ²ÙŠØ¯ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¸Ù‡ÙˆØ±', cost:110, max:5, deps:['fireRate'], apply:lvl=> spawnConfig.spawnInterval = Math.max(spawnConfig.minSpawnInterval, spawnConfig.baseSpawnInterval - lvl*100)},
  rockSpeed: {name:'Ø³Ø±Ø¹Ø© Ø§Ù„ØµØ®ÙˆØ±', desc:'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„ØµØ®ÙˆØ±', cost:110, max:5, deps:['rockDensity'], apply:lvl=> spawnConfig.baseRockSpeed = 0.45 + lvl*0.12},
  homing: {name:'ØªØªØ¨Ø¹', desc:'ØªØ­Ø³Ù† ØªØªØ¨Ø¹ Ø§Ù„ØµÙˆØ§Ø±ÙŠØ®', cost:130, max:3, deps:['missiles'], apply:lvl=> player.homing = lvl},
  shield: {name:'Ø¯Ø±Ø¹', desc:'Ø¯Ø±Ø¹ ÙŠÙ…ØªØµ Ø¶Ø±Ø± Ù…Ø¤Ù‚Øª', cost:190, max:3, deps:['hpMax'], apply:lvl=> player.shieldMax = lvl*8},
  split: {name:'ØªØ´Ø¸ÙŠ', desc:'ØªØµÙ†Ø¹ Ø´Ø¸Ø§ÙŠØ§ Ø¹Ù†Ø¯ Ø§Ù„Ø§ØµØ§Ø¨Ø©', cost:170, max:3, deps:['explosion'], apply:lvl=> player.split = lvl},
  speed: {name:'Ø³Ø±Ø¹Ø©', desc:'ØªØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©', cost:100, max:4, deps:[], apply:lvl=> player.speed = 3 + lvl*1.0}
};
if(!state.upgrades) state.upgrades = {};
for(const k in UP) if(state.upgrades[k]===undefined) state.upgrades[k] = 0;
function applyAllUpgrades(){
  player.damage = 3; player.fireRate = 1800; player.missiles = 1; player.missileSpeed = 6; player.moneyMul = 1; player.regen = 0; player.shieldMax = 0; player.explosion = 0; player.homing=0; player.split=0; player.speed=3; player.maxHealth=20;
  for(const id in UP){ const lvl = state.upgrades[id]||0; if(typeof UP[id].apply === 'function') UP[id].apply(lvl); }
  if(!player.health) player.health = player.maxHealth;
}
applyAllUpgrades();

/* --------------------------- inputs & joystick --------------------------- */
let mouse = {x:player.x, y:player.y};
addEventListener('mousemove', e=>{ if(mode==='pc'){ mouse.x = e.clientX; mouse.y = e.clientY; }});
let stickPos = {x:0,y:0};
let activeTouchId = null;
game.addEventListener('touchstart', ev=>{ if(mode!=='mobile') return; const t = ev.touches[0]; activeTouchId = t.identifier; });
game.addEventListener('touchmove', ev=>{ if(mode!=='mobile') return; for(const t of ev.touches){ if(t.identifier === activeTouchId){ const dx = t.clientX - innerWidth/2; const dy = t.clientY - (innerHeight - 120); const max = 60; const mag = Math.hypot(dx,dy); const clx = (mag>max)? dx*max/mag : dx; const cly = (mag>max)? dy*max/mag : dy; stick.style.transform = `translate(${clx}px, ${cly}px)`; stickPos = {x:clx/max, y:cly/max}; } }});
game.addEventListener('touchend', ev=>{ activeTouchId=null; stick.style.transform='translate(0,0)'; stickPos={x:0,y:0}; });

const keys = {}; addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key.toLowerCase()==='u') toggleTree(); });
addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* --------------------------- firing & destroy --------------------------- */
function autoFire(now){
  if(now - game.lastFire < (player.fireRate || 1800)) return;
  game.lastFire = now;
  const count = player.missiles || 1;
  for(let i=0;i<count;i++){
    if(rocks.length===0) return;
    let target = rocks.reduce((a,b)=> (Math.hypot(a.x-player.x,a.y-player.y) < Math.hypot(b.x-player.x,b.y-player.y) ? a : b));
    if(Math.random() < 0.18 && rocks.length>2) target = rocks[Math.floor(Math.random()*rocks.length)];
    const angle = Math.atan2((target.y-player.y)+(Math.random()-0.5)*30, (target.x-player.x)+(Math.random()-0.5)*30);
    const vx = Math.cos(angle)*(player.missileSpeed||6), vy = Math.sin(angle)*(player.missileSpeed||6);
    missiles.push({ x:player.x + Math.cos(angle)*player.r, y:player.y + Math.sin(angle)*player.r, vx, vy, target });
  }
  playFX('fire');
}

function destroyRock(i){
  const r = rocks[i]; if(!r) return;
  const reward = Math.ceil(r.value * (player.moneyMul || 1));
  state.money = (state.money || 0) + reward; state.score = (state.score || 0) + Math.ceil(r.r/2);
  for(let p=0;p<18;p++) particles.push({x:r.x,y:r.y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,life:24,col:'#ffd4a3'});
  if(!r.golden && r.r > 22){
    const parts = Math.min(3, Math.floor(r.r/14));
    for(let k=0;k<parts;k++) rocks.push({ x: r.x + (Math.random()-0.5)*20, y: r.y + (Math.random()-0.5)*20, r: r.r*(0.45+Math.random()*0.2), hp: Math.ceil(r.r*0.5), vx:(Math.random()*1-0.5)*1.2, vy:(Math.random()*1-0.5)*1.2, baseSpeed: 0.3 + Math.random()*0.6, value: Math.ceil(r.r*0.4/3)*6, golden:false });
  }
  rocks.splice(i,1);
  setTimeout(()=> spawnRock(Math.floor(Math.random()*4)), 600 + Math.random()*900);
  playFX('destroy'); saveState();
}

/* --------------------------- difficulty escalation --------------------------- */
function maybeIncreaseDifficulty(now){
  // increase difficulty every DIFF_INCREASE_INTERVAL of surviving
  const survived = now - startSurvival;
  const increments = Math.floor(survived / DIFF_INCREASE_INTERVAL);
  if(increments > difficultyLevel){
    difficultyLevel = increments;
    // decrease spawn interval gradually
    spawnConfig.spawnInterval = Math.max(spawnConfig.minSpawnInterval, spawnConfig.baseSpawnInterval - difficultyLevel * 90);
    // increase golden chance gradually but capped
    goldenChance = Math.min(MAX_GOLDEN_CHANCE, 0.01 + difficultyLevel * 0.02);
    // slightly increase base rock speed
    spawnConfig.baseRockSpeed = Math.min(1.4, spawnConfig.baseRockSpeed + difficultyLevel * 0.02);
    // give a small audio cue
    playFX('upgrade');
  }
  // also increase difficulty based on score
  const extraFromScore = Math.floor((state.score||0) / 50);
  if(extraFromScore > difficultyLevel){
    difficultyLevel = extraFromScore;
    spawnConfig.spawnInterval = Math.max(spawnConfig.minSpawnInterval, spawnConfig.baseSpawnInterval - difficultyLevel * 90);
    goldenChance = Math.min(MAX_GOLDEN_CHANCE, goldenChance + 0.01);
  }
}

/* --------------------------- spawn loop wrapper --------------------------- */
const game = { paused:false, baseSpawn: spawnConfig.baseSpawnInterval, spawnInterval: spawnConfig.spawnInterval, rockBase:spawnConfig.baseRockSpeed, lastSpawn:performance.now(), lastFire:performance.now(), passiveTick:performance.now() };

/* --------------------------- render helpers --------------------------- */
function renderBG(now){
  ctxBG.clearRect(0,0,bg.width,bg.height);
  const grd = ctxBG.createLinearGradient(0,0,bg.width,bg.height);
  grd.addColorStop(0,'#001428'); grd.addColorStop(0.6,'#020213'); grd.addColorStop(1,'#000008');
  ctxBG.fillStyle = grd; ctxBG.fillRect(0,0,bg.width,bg.height);
  const t = now * 0.00004;
  for(let i=0;i<5;i++){
    const rx = (Math.sin(t*(i+1)+i)+1)/2 * bg.width;
    const ry = (Math.cos(t*(i+2)+i)+1)/2 * bg.height;
    const rad = Math.min(bg.width,bg.height) * (0.12 + i*0.04);
    const g = ctxBG.createRadialGradient(rx,ry,rad*0.1, rx,ry,rad);
    g.addColorStop(0, `rgba(139,92,255,${0.02 + i*0.01})`);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctxBG.fillStyle = g; ctxBG.fillRect(rx-rad,ry-rad,rad*2,rad*2);
  }
  for(let i=0;i<180;i++){
    const x = (i*37) % bg.width;
    const y = (i*97 + (now*0.01)) % bg.height;
    ctxBG.fillStyle = 'rgba(255,255,255,' + (0.28 + (Math.sin((now*0.002)+i)*0.18)) + ')';
    ctxBG.fillRect(x, y, 1.5, 1.5);
  }
}

function drawShip(p){
  ctx.save(); ctx.translate(p.x, p.y);
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,240,255,0.06)'; ctx.arc(0,0,p.r+22,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(p.r,0); ctx.lineTo(-p.r*0.7, -p.r*0.9); ctx.lineTo(-p.r*0.7, p.r*0.9); ctx.closePath();
  const g = ctx.createLinearGradient(-p.r, -p.r, p.r, p.r); g.addColorStop(0,'#bff'); g.addColorStop(1,'#6ee');
  ctx.fillStyle = g; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.beginPath(); ctx.fillStyle = '#012028'; ctx.arc(-p.r*0.25,0,p.r*0.42,0,Math.PI*2); ctx.fill();
  if(p.shield && p.shield > 0){ ctx.beginPath(); ctx.strokeStyle = 'rgba(120,240,255,0.5)'; ctx.lineWidth = 4; ctx.arc(0,0,p.r+12,0,Math.PI*2); ctx.stroke(); }
  ctx.restore();
}

function drawRock(r){
  if(r.golden){
    // golden rock look
    const grad = ctx.createRadialGradient(r.x - r.r*0.2, r.y - r.r*0.2, r.r*0.1, r.x, r.y, r.r);
    grad.addColorStop(0, '#fff4c8'); grad.addColorStop(0.6, '#f5d06a'); grad.addColorStop(1, '#9a6b14');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,230,140,0.25)'; ctx.lineWidth = 2; ctx.stroke();
  } else {
    const grad = ctx.createRadialGradient(r.x - r.r*0.3, r.y - r.r*0.3, r.r*0.1, r.x, r.y, r.r);
    grad.addColorStop(0, '#ddd'); grad.addColorStop(0.6, '#9a9a9a'); grad.addColorStop(1, '#454545');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.lineWidth = 1; ctx.beginPath();
    ctx.moveTo(r.x - r.r*0.5, r.y - r.r*0.2); ctx.lineTo(r.x + r.r*0.2, r.y + r.r*0.6); ctx.stroke();
  }
  ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(r.x - r.r, r.y - r.r - 8, r.r*2, 6);
  const maxHp = Math.ceil(r.r/3)*6 * (r.golden?1.9:1);
  ctx.fillStyle = r.golden? '#ffd36b' : '#ff6b6b';
  ctx.fillRect(r.x - r.r, r.y - r.r - 8, (r.hp / maxHp) * r.r*2, 6);
}

/* --------------------------- main loop --------------------------- */
let last = performance.now();
function loop(now){
  const dt = now - last;
  renderBG(now);
  if(!game.paused){
    // difficulty management
    maybeIncreaseDifficulty(now);

    // update player
    if(mode==='pc'){
      const dx = mouse.x - player.x, dy = mouse.y - player.y;
      player.x += dx * 0.06 * (dt/16); player.y += dy * 0.06 * (dt/16);
    } else if(mode==='mobile'){
      player.x += (stickPos.x||0) * player.speed * 4 * (dt/16);
      player.y += (stickPos.y||0) * player.speed * 4 * (dt/16);
    } else {
      let ax=0, ay=0; if(keys['w']) ay-=1; if(keys['s']) ay+=1; if(keys['a']) ax-=1; if(keys['d']) ax+=1;
      const mag = Math.hypot(ax,ay)||1;
      player.x += (ax/mag) * player.speed * 2 * (dt/16); player.y += (ay/mag) * player.speed * 2 * (dt/16);
    }
    player.x = Math.max(0, Math.min(innerWidth, player.x));
    player.y = Math.max(0, Math.min(innerHeight, player.y));

    // rocks physics (move by vx,vy; occasional small random drift)
    for(let i=rocks.length-1;i>=0;i--){
      const r = rocks[i];
      // apply base speed scaling from upgrades/difficulty
      const speedScale = 1 + ((state.upgrades && state.upgrades.rockSpeed)||0)*0.05 + difficultyLevel*0.02;
      r.x += r.vx * speedScale * (dt/16);
      r.y += r.vy * speedScale * (dt/16);
      // slight drift random
      r.vx += (Math.random()-0.5)*0.01; r.vy += (Math.random()-0.5)*0.01;
      // wrap edges
      if(r.x < -r.r - 30) r.x = innerWidth + r.r + 10;
      if(r.x > innerWidth + r.r + 30) r.x = -r.r - 10;
      if(r.y < -r.r - 30) r.y = innerHeight + r.r + 10;
      if(r.y > innerHeight + r.r + 30) r.y = -r.r - 10;
      // collision with player
      const dist = Math.hypot(r.x - player.x, r.y - player.y);
      if(dist < r.r + player.r){
        let dmg = 2;
        if(player.shield && player.shield > 0){ const take = Math.min(player.shield, dmg); player.shield -= take; dmg -= take; }
        player.health -= dmg;
        r.x += (r.x - player.x)/Math.max(dist,1) * 18; r.y += (r.y - player.y)/Math.max(dist,1) * 18;
        for(let k=0;k<6;k++) particles.push({x:player.x+(Math.random()-0.5)*24,y:player.y+(Math.random()-0.5)*24,vx:(Math.random()-0.5)*3,vy:(Math.random()-0.5)*3,life:12,col:'#ff9d9d'});
        playFX('hit');
        if(Math.random() < 0.07) destroyRock(i);
      }
      if(r.hp <= 0) destroyRock(i);
    }

    // missiles homing and collisions
    for(let i=missiles.length-1;i>=0;i--){
      const m = missiles[i];
      if(m.target && rocks.includes(m.target)){
        const tx = m.target.x, ty = m.target.y; const dx = tx - m.x, dy = ty - m.y; const d = Math.hypot(dx,dy)||1;
        const homing = 0.9 + ((player.homing||0)*0.07);
        m.vx = (m.vx * (1-homing)) + (dx/d) * player.missileSpeed * homing;
        m.vy = (m.vy * (1-homing)) + (dy/d) * player.missileSpeed * homing;
      }
      m.x += m.vx * (dt/16); m.y += m.vy * (dt/16);
      if(m.x < -30) m.x = innerWidth + 30;
      if(m.x > innerWidth + 30) m.x = -30;
      if(m.y < -30) m.y = innerHeight + 30;
      if(m.y > innerHeight + 30) m.y = -30;
      for(let j=rocks.length-1;j>=0;j--){
        const r = rocks[j];
        if(Math.hypot(r.x - m.x, r.y - m.y) < r.r + 6){
          const crit = Math.random() < (player.crit||0); const dmg = player.damage * (crit?2:1);
          r.hp -= dmg;
          for(let p=0;p<10;p++) particles.push({x:m.x,y:m.y,vx:(Math.random()-0.5)*4,vy:(Math.random()-0.5)*4,life:18,col: crit ? '#ffd46a' : '#ffb2b2'});
          playFX('hit');
          if(player.explosion){
            const rad = 26 * player.explosion;
            for(let rr=rocks.length-1; rr>=0; rr--){
              if(rr!==j){
                const dd = Math.hypot(rocks[rr].x - m.x, rocks[rr].y - m.y);
                if(dd < rad) rocks[rr].hp -= Math.ceil(dmg*0.5);
              }
            }
          }
          missiles.splice(i,1);
          break;
        }
      }
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.x += p.vx * (dt/16); p.y += p.vy * (dt/16); p.vx *= 0.98; p.vy *= 0.98; p.life--; if(p.life<=0) particles.splice(i,1); }

    // passive regen
    if(player.regen && now - game.passiveTick > 2000){ player.health = Math.min(player.maxHealth, player.health + player.regen); game.passiveTick = now; }

    // spawn & auto-fire
    if(now - game.lastSpawn > spawnConfig.spawnInterval){ game.lastSpawn = now; // possibly spawn multiple based on difficulty
      // spawn base one
      spawnRock(Math.floor(Math.random()*4));
      // spawn an extra rock occasionally when difficulty is higher
      if(Math.random() < Math.min(0.5, difficultyLevel * 0.08)) spawnRock(Math.floor(Math.random()*4));
    }
    autoFire(now);

    // death
    if(player.health <= 0){
      game.paused = true;
      playFX('death');
      // reset survival timer on death
      startSurvival = performance.now();
      difficultyLevel = 0;
      goldenChance = 0.01;
    }
  }

  // render
  ctx.clearRect(0,0,game.width,game.height);
  for(const r of rocks) drawRock(r);
  for(const m of missiles){ ctx.beginPath(); ctx.fillStyle = 'rgba(255,150,110,0.95)'; ctx.arc(m.x, m.y, 4, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(255,200,130,0.2)'; ctx.fillRect(m.x-2, m.y-10, 4, 8); }
  for(const p of particles) { ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 2,2); }
  drawShip(player);
  document.getElementById('hpVal').textContent = Math.max(0, Math.floor(player.health));
  document.getElementById('moneyVal').textContent = Math.floor(state.money || 0);
  document.getElementById('scoreVal').textContent = Math.floor(state.score || 0);
  document.getElementById('dmgVal').textContent = player.damage;
  last = now; requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* --------------------------- UI & settings handling --------------------------- */
const modal = document.getElementById('settingsModal'), openSettings = document.getElementById('openSettings'), closeSettings = document.getElementById('closeSettings'), saveSettings = document.getElementById('saveSettings');
const controlSelect = document.getElementById('controlSelect'), volRange = document.getElementById('volRange'), fxToggle = document.getElementById('fxToggle');

openSettings.addEventListener('click', ()=>{
  controlSelect.value = state.settings.mode || 'pc';
  volRange.value = state.settings.volume || 0.6;
  fxToggle.checked = state.settings.fx !== false;
  modal.style.display = 'flex';
});
closeSettings.addEventListener('click', ()=>{ modal.style.display = 'none'; });
saveSettings.addEventListener('click', ()=>{
  state.settings.mode = controlSelect.value;
  state.settings.volume = parseFloat(volRange.value);
  state.settings.fx = fxToggle.checked;
  setVolume(state.settings.volume);
  mode = state.settings.mode;
  if(mode === 'mobile') joystick.style.display = 'block'; else joystick.style.display = 'none';
  modal.style.display = 'none'; saveState(); playFX('upgrade');
});

/* --------------------------- tree / upgrade UI (reused) --------------------------- */
const openTreeBtn = document.getElementById('openTree'), upgradeOverlay = document.getElementById('upgradeOverlay'), closeTreeBtn = document.getElementById('closeTreeBtn'), resetTree = document.getElementById('resetTree'), treeArea = document.getElementById('treeArea'), tooltip = document.getElementById('tooltip');
openTreeBtn.addEventListener('click', ()=>{ upgradeOverlay.style.display='flex'; game.paused = true; renderTree(); });
document.getElementById('closeTreeBtn').addEventListener('click', ()=>{ upgradeOverlay.style.display='none'; game.paused=false; saveState(); });
resetTree.addEventListener('click', ()=>{ if(confirm('Ø§Ø¹Ø¯ ØªØ¹ÙŠÙŠÙ† ÙƒÙ„ Ø§Ù„ØªØ·ÙˆÙŠØ±Ø§ØªØŸ')){ for(const k in state.upgrades) state.upgrades[k]=0; state.money=0; state.score=0; applyAllUpgrades(); saveState(); renderTree(); } });

const layout = [
  {id:'damage', x:160, y:90},{id:'fireRate', x:420, y:200},{id:'missiles', x:720, y:200},
  {id:'missileSpeed', x:720, y:340},{id:'explosion', x:980, y:440},{id:'split', x:1180, y:560},
  {id:'money', x:520, y:360},{id:'hpMax', x:200, y:360},{id:'regen', x:200, y:520},
  {id:'rockDensity', x:640, y:520},{id:'rockSpeed', x:860, y:640},{id:'homing', x:960, y:320},
  {id:'shield', x:40, y:640},{id:'speed', x:40, y:840}
];

function isUnlockedNode(id){ const def = UP[id]; if(!def) return false; if(def.deps.length === 0) return true; return def.deps.some(d => (state.upgrades[d] && state.upgrades[d] > 0)); }

function renderTree(){
  treeArea.innerHTML = '';
  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('width','100%'); svg.setAttribute('height','100%'); svg.style.position='absolute'; svg.style.left='0'; svg.style.top='0';
  treeArea.appendChild(svg);
  const cont = document.createElement('div'); cont.style.position='absolute'; cont.style.left='0'; cont.style.top='0'; cont.style.width='2200px'; cont.style.height='1600px'; treeArea.appendChild(cont);
  const pos = {}; layout.forEach(n=> pos[n.id] = {x: n.x + 95, y: n.y + 30});
  layout.forEach(node=>{
    const def = UP[node.id]; if(!def) return;
    def.deps.forEach(dep=>{
      if(!pos[dep]) return;
      const p1 = pos[dep], p2 = pos[node.id]; const mx = (p1.x + p2.x)/2;
      const d = `M ${p1.x} ${p1.y} C ${mx} ${p1.y-70}, ${mx} ${p2.y+70}, ${p2.x} ${p2.y}`;
      const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d',d);
      const color = (state.upgrades[dep] && state.upgrades[dep]>0) ? 'rgba(0,240,255,0.95)' : 'rgba(255,255,255,0.06)';
      path.setAttribute('stroke', color); path.setAttribute('stroke-width','3'); path.setAttribute('fill','none'); svg.appendChild(path);
    });
  });
  layout.forEach(node=>{
    const def = UP[node.id]; if(!def) return;
    const el = document.createElement('div'); el.className='node'; el.style.left = node.x + 'px'; el.style.top = node.y + 'px';
    const lvl = state.upgrades[node.id] || 0;
    el.innerHTML = `<div class="lvl">Lv.${lvl}/${def.max}</div><div class="title">${def.name}</div><div class="sub">${def.desc}</div><div class="cost">${def.cost}ğŸ’ </div>`;
    if(lvl >= def.max) el.classList.add('locked');
    else if(isUnlockedNode(node.id) && (state.money || 0) >= def.cost) el.classList.add('buyable');
    else if(isUnlockedNode(node.id)) el.classList.add('unlocked');
    else el.classList.add('locked');
    el.addEventListener('mouseenter', ev=>{ tooltip.style.left = (ev.clientX+12)+'px'; tooltip.style.top = (ev.clientY+12)+'px'; tooltip.style.display='block'; tooltip.innerHTML = `<b>${def.name}</b><br>${def.desc}<br>ØªÙƒÙ„ÙØ©: ${def.cost} â€¢ Ø§Ù„Ø­Ø¯: ${def.max} â€¢ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${lvl}`; });
    el.addEventListener('mousemove', ev=>{ tooltip.style.left = (ev.clientX+12)+'px'; tooltip.style.top = (ev.clientY+12)+'px'; });
    el.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; });
    el.addEventListener('click', ()=>{
      if(state.upgrades[node.id] >= def.max){ alert('ÙˆØµÙ„Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰'); return; }
      if(!isUnlockedNode(node.id)){ alert('Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù‚Ø¯Ø© Ù…Ù‚ÙÙ„Ø©'); return; }
      if((state.money || 0) < def.cost){ alert('ÙÙ„ÙˆØ³Ùƒ Ù‚Ù„ÙŠÙ„Ø©'); return; }
      state.money -= def.cost; state.upgrades[node.id] = (state.upgrades[node.id]||0) + 1;
      UP[node.id].cost = Math.ceil(def.cost * 1.25);
      applyAllUpgrades(); saveState(); renderTree(); playFX('upgrade');
    });
    cont.appendChild(el);
  });

  // drag
  let mouseDown=false, sx=0, sy=0, ox=0, oy=0;
  treeArea.style.left = Math.max(0, (innerWidth - 1200)/2) + 'px';
  treeArea.style.top = Math.max(0, (innerHeight - 800)/2) + 'px';
  treeArea.onmousedown = e=>{ mouseDown=true; sx=e.clientX; sy=e.clientY; ox=parseInt(treeArea.style.left||0); oy=parseInt(treeArea.style.top||0); treeArea.style.cursor='grabbing'; }
  window.addEventListener('mousemove', e=>{ if(!mouseDown) return; const dx = e.clientX - sx; const dy = e.clientY - sy; treeArea.style.left = (ox + dx) + 'px'; treeArea.style.top = (oy + dy) + 'px'; });
  window.addEventListener('mouseup', ()=>{ mouseDown=false; treeArea.style.cursor='grab'; });
}

/* --------------------------- helper: toggle tree & save --------------------------- */
function toggleTree(){ const ov = document.getElementById('upgradeOverlay'); if(ov.style.display === 'flex') { ov.style.display='none'; game.paused=false; saveState(); } else { document.getElementById('upgradeOverlay').style.display='flex'; game.paused=true; renderTree(); } }
document.getElementById('openTree').addEventListener('click', ()=>{ toggleTree(); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ if(confirm('ØªØ­Ø°Ù Ø§Ù„Ø­ÙØ¸ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ ÙˆØªØ¹ÙŠØ¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©ØŸ')){ localStorage.removeItem(SAVE); location.reload(); } });

/* --------------------------- save/load --------------------------- */
function saveState(){ localStorage.setItem(SAVE, JSON.stringify(state)); }

/* --------------------------- initial UI values --------------------------- */
document.getElementById('controlSelect').value = state.settings.mode || 'pc';
document.getElementById('volRange').value = state.settings.volume || 0.6;
document.getElementById('fxToggle').checked = state.settings.fx !== false;

/* --------------------------- periodic tasks --------------------------- */
setInterval(()=> saveState(), 6000);
setInterval(()=>{ // small periodic adjust: make spawnConfig reflect difficulty
  spawnConfig.spawnInterval = Math.max(spawnConfig.minSpawnInterval, spawnConfig.baseSpawnInterval - difficultyLevel * 90);
}, 4000);

/* --------------------------- done --------------------------- */
</script>
</body>
</html>
